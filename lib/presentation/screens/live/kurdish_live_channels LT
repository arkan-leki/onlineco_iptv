part of '../screens.dart';

class KurdishLiveChannelsScreen extends StatefulWidget {
  const KurdishLiveChannelsScreen({super.key, required this.catyId});
  final String catyId;

  @override
  State<KurdishLiveChannelsScreen> createState() => _KurdishListChannelsScreen();
}

class _KurdishListChannelsScreen extends State<KurdishLiveChannelsScreen> {
  VlcPlayerController? _videoPlayerController;

  int? selectedVideo;
  String? selectedStreamId;
  ChannelLive? channelLive;
  double lastPosition = 0.0;
  String keySearch = "";
  final FocusNode _remoteFocus = FocusNode();

  _initialVideo(String streamId) async {
    UserModel? user = await LocaleApi.getUser();

    // Dispose of existing video controller if it's playing
    if (_videoPlayerController != null && _videoPlayerController!.value.isInitialized) {
      await _videoPlayerController!.stop();
      await _videoPlayerController!.dispose();
      _videoPlayerController = null;
      await Future.delayed(const Duration(milliseconds: 300));
    }

    // Start the new video
    final videoUrl =
        "${user!.serverInfo!.serverUrl}/${user.userInfo!.username}/${user.userInfo!.password}/$streamId";

    debugPrint("Loading Video: $videoUrl");
    _videoPlayerController = VlcPlayerController.network(
      videoUrl,
      hwAcc: HwAcc.full,
      autoPlay: true,
      options: VlcPlayerOptions(
        advanced: VlcAdvancedOptions([
          VlcAdvancedOptions.networkCaching(2000),
          VlcAdvancedOptions.liveCaching(2000),
        ]),
        http: VlcHttpOptions([
          VlcHttpOptions.httpReconnect(true),
        ]),
        rtp: VlcRtpOptions([
          VlcRtpOptions.rtpOverRtsp(true),
        ]),
      ),
    );

    setState(() {}); // Update the UI to reflect the new video controller
  }

  @override
  void initState() {
    context.read<ChannelsBloc>().add(GetLiveChannelsEvent(
      catyId: widget.catyId,
      typeCategory: TypeCategory.live,
    ));
    super.initState();
  }

  @override
  void dispose() async {
    _remoteFocus.dispose();
    // Dispose of video player when leaving screen
    if (_videoPlayerController != null) {
      await _videoPlayerController!.stopRendererScanning();
      await _videoPlayerController!.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<VideoCubit, VideoState>(
      builder: (context, stateVideo) {
        return WillPopScope(
          onWillPop: () async {
            debugPrint("Back pressed");
            if (stateVideo.isFull) {
              context.read<VideoCubit>().changeUrlVideo(false);
              return Future.value(false);
            } else {
              return Future.value(true);
            }
          },
          child: BlocBuilder<AuthBloc, AuthState>(
            builder: (context, stateAuth) {
              if (stateAuth is AuthSuccess) {
                final userAuth = stateAuth.user;

                return Scaffold(
                  body: Stack(
                    alignment: Alignment.bottomCenter,
                    children: [
                      Ink(
                        width: 100.w,
                        height: 100.h,
                        decoration: kDecorBackground,
                        child: Column(
                          children: [
                            Builder(
                              builder: (context) {
                                if (stateVideo.isFull) {
                                  return const SizedBox();
                                }
                                return WillPopScope(
                                  onWillPop: () async {
                                    debugPrint("Back pressed");
                                    if (stateVideo.isFull) {
                                      context.read<VideoCubit>().changeUrlVideo(false);
                                      return Future.value(false);
                                    } else {
                                      return Future.value(true);
                                    }
                                  },
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      SizedBox(height: 3.h),
                                      BlocBuilder<FavoritesCubit, FavoritesState>(
                                        builder: (context, state) {
                                          final isLiked = channelLive == null
                                              ? false
                                              : state.lives
                                                  .where((live) => live.streamId == channelLive!.streamId)
                                                  .isNotEmpty;

                                          return AppBarLive(
                                            onChannels: () {
                                              Get.toNamed('/categories-live');
                                            },
                                            onMovies: () {
                                              Get.toNamed('/categories-movie');
                                            },
                                            onSeries: () {
                                              Get.toNamed('/categories-series');
                                            },
                                            isLiked: isLiked,
                                            onLike: channelLive == null ? null : () {
                                              context.read<FavoritesCubit>().addLive(channelLive, isAdd: !isLiked);
                                            },
                                            onSearch: (String value) {
                                              setState(() {
                                                keySearch = value;
                                              });
                                            },
                                            onClose: () {
                                              Get.back(); // Just navigate back without stopping the player
                                            },
                                          );
                                        },
                                      ),
                                      const SizedBox(height: 15),
                                    ],
                                  ),
                                );
                              },
                            ),
                            Expanded(
                              child: Row(
                                children: [
                                  Builder(
                                    builder: (context) {
                                      bool setFull = stateVideo.isFull;
                                      if (setFull) {
                                        return const SizedBox();
                                      }
                                      return Expanded(
                                        child: BlocBuilder<ChannelsBloc, ChannelsState>(
                                          builder: (context, state) {
                                            if (state is ChannelsLoading) {
                                              return const Center(child: CircularProgressIndicator());
                                            } else if (state is ChannelsLiveSuccess) {
                                              final categories = state.channels;

                                              List<ChannelLive> searchList =
                                                  categories.where((element) => element.name!.toLowerCase().contains(keySearch)).toList();

                                              return GridView.builder(
                                                padding: const EdgeInsets.only(left: 10, right: 10, bottom: 80),
                                                itemCount: keySearch.isEmpty ? categories.length : searchList.length,
                                                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                                                  crossAxisCount: selectedVideo == null ? 3 : 1,
                                                  mainAxisSpacing: 10,
                                                  crossAxisSpacing: selectedVideo == null ? 10 : 0,
                                                  childAspectRatio: 7,
                                                ),
                                                itemBuilder: (_, i) {
                                                  final model = keySearch.isEmpty ? categories[i] : searchList[i];
                                                  final link = "${userAuth.serverInfo!.serverUrl}/${userAuth.userInfo!.username}/${userAuth.userInfo!.password}/${model.streamId}";

                                                  return CardLiveItem(
                                                    title: model.name ?? "",
                                                    image: model.streamIcon,
                                                    link: link,
                                                    isSelected: selectedVideo == null ? false : selectedVideo == i,
                                                    onTap: () async {
                                                      try {
                                                        if (selectedVideo == i && _videoPlayerController != null) {
                                                          // Open full screen
                                                          debugPrint("///////////// OPEN FULL STREAM /////////////");
                                                          context.read<VideoCubit>().changeUrlVideo(true);
                                                        } else {
                                                          // Stop previous video and play new stream
                                                          _stopCurrentVideo();
                                                          _initialVideo(model.streamId.toString());

                                                          if (mounted) {
                                                            setState(() {
                                                              selectedVideo = i;
                                                              channelLive = model;
                                                              selectedStreamId = model.streamId;
                                                            });
                                                          }
                                                        }
                                                      } catch (e) {
                                                        debugPrint("error: $e");
                                                        _videoPlayerController = null;
                                                        setState(() {
                                                          channelLive = model;
                                                          selectedStreamId = model.streamId;
                                                        });
                                                      }
                                                    },
                                                  );
                                                },
                                              );
                                            }

                                            return const Center(child: Text("Failed to load data..."));
                                          },
                                        ),
                                      );
                                    },
                                  ),
                                  if (selectedVideo != null)
                                    Expanded(
                                      child: Column(
                                        children: [
                                          // Close Button for the player
                                          Align(
                                            alignment: Alignment.topRight,
                                            child: IconButton(
                                              icon: const Icon(Icons.close, color: Colors.white),
                                              onPressed: () {
                                                _stopCurrentVideo();
                                                setState(() {
                                                  selectedVideo = null; // Hide the player view
                                                });
                                              },
                                            ),
                                          ),
                                          Expanded(
                                            flex: 1,
                                            child: StreamPlayerPage(
                                              controller: _videoPlayerController,
                                            ),
                                          ),
                                          Builder(
                                            builder: (context) {
                                              if (stateVideo.isFull) {
                                                return const SizedBox();
                                              }
                                              return CardEpgStream(streamId: selectedStreamId);
                                            },
                                          ),
                                        ],
                                      ),
                                    ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                      if (selectedVideo == null) AdmobWidget.getBanner(),
                    ],
                  ),
                );
              }

              return const Scaffold();
            },
          ),
        );
      },
    );
  }

  // Method to stop the current video and dispose of the controller
  void _stopCurrentVideo() async {
    if (_videoPlayerController != null && _videoPlayerController!.value.isInitialized) {
      await _videoPlayerController!.pause();
      await _videoPlayerController!.stop();
      await _videoPlayerController!.dispose();
      _videoPlayerController = null;
      debugPrint("Stopped and disposed of current video.");
    }
  }
}
